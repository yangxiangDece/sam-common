package com.yang.design.mode;

/**
 * 设计原则：
 *      1、找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
 *      2、针对接口编程，而不是针对实现编程
 *      3、多用组合，少用继承
 *      4、为了交互对象之间的松耦合设计而努力。
 *      5、开闭原则，类应该对扩展开放，对修改关闭
 *      6、依赖倒置原则，要依赖抽象，不要依赖具体类。不能让高层组件依赖底层组件，而且不管是高层组件还是底层组件，两者都应该依赖于抽象。
 *          所谓高层组件，是由其他底层组件定义其行为的类。例如，PizzaStore是个高层组件，因为它的行为是由比萨定义的。PizzaStore创建所有不同的比萨对象，而比萨本身属于底层组件。
 *      7、最少知识原则：不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。
 *      8、好莱坞原则：别调用我们，我们会调用你。我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些底层组件，换言之，高层组件对待底层组件就是：别调用我们，我们会调用你
 *      9、类的单一职责
 *      10、
 * 设计模式：
 *      1、策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
 *      2、观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
 *          com.yang.design.mode.observer.myself包：自定义的观察者模式
 *          com.yang.design.mode.observer.jdk包：Java jdk自带的观察者模式(Observer(观察者)接口和Observable(可观察者)类)
 *      3、装饰模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
 *          装饰者可以在所委托的被装饰者的行为之前/或之后，加上自己的行为，以达到特定的目的。
 *      4、工厂方法模式：定义了一个创建对象的接口，但由子类绝对要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
 *          工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象
 *      5、抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
 *          抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中
 *      6、单件模式（单例模式）：确保一个类只有一个实例，并提供一个全局访问点
 *      7、命令模式：将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
 *      8、适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
 *          适配器实现目标接口，并持有被适配器者的实例
 *          对象适配器：采用组合的形式
 *          类适配器：采用继承的形式，需要多重继承才能实现它，在java中无法实现。
 *      9、外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
 *          注意：请务必记得外观模式的意图：要提供一个简单的接口，好让子系统更易于使用。
 *          外观不只是简化接口，也将客户从组件的子系统中解耦
 *          外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同的接口
 *      10、模板方法模式：在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算分中的某些步骤
 *          这个方法将算分定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负债实现。这可以确保算法的结构保持不变，自己可以实现一些公共方法，也可以由子类提供部分实现。
 *      11、迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。集合也被称为聚合(aggregate)
 *          迭代器模式让我们游走于集合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是集合上。这样简化了集合的接口和实现，也让责任各得其所。
 *      12、组合模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
 *          使用组合结构，我们把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。
 *          组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。
 *          同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。
 *          如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。
 *          组合模式的引入将在一定程度上解决这些问题。
 *          组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点。
 *      13、状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像改变了它的类。
 *      14、代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、
 *          创建开销大的对象或需要安全控制的对象。主要作用是：控制访问
 *          动态代理：运行时才将类创建出来，代码开始执行时，还没有proxy类，它是根据需要从你传入的接口集创建的
 *      15、复合模式：
 *
 */
public class MainNote {
}
